.ORG 50

: SP        8 ;
: RSP      12 ;
: (HERE)   16 ;
: (LAST)   20 ;
: STATE    24 ;
: BASE     28 ;
: (STACK)  32 ;
: (RSTACK) 36 ;
: STDIN    40 ;
: INPUT-FP 44 ;
: >IN      48 ;

: HERE (HERE) @ ;
: LAST (LAST) @ ;

: , HERE ! HERE 4 + (HERE) ! ;
: C, HERE C! HERE 1 + (HERE) ! ;

: HEX 16 BASE ! ;
: DECIMAL 10 BASE ! ;

: ?COMPILING STATE @ ;
: [ 0 STATE ! ;
: ] 1 STATE ! ;

:! !  ?COMPILING IF <asm> CPUSH STORE  </asm> C, <asm> RET </asm> THEN ! ;
:! C! ?COMPILING IF <asm> CPUSH CSTORE </asm> C, <asm> RET </asm> THEN C! ;

:! @  ?COMPILING IF <asm> CPUSH FETCH  </asm> C, <asm> RET </asm> THEN @ ;
:! C@ ?COMPILING IF <asm> CPUSH CFETCH </asm> C, <asm> RET </asm> THEN C@ ;

:! + ?COMPILING IF <asm> CPUSH ADD </asm> C, <asm> RET </asm> THEN + ;
:! - ?COMPILING IF <asm> CPUSH SUB </asm> C, <asm> RET </asm> THEN - ;
:! * ?COMPILING IF <asm> CPUSH MUL </asm> C, <asm> RET </asm> THEN * ;
:! / ?COMPILING IF <asm> CPUSH DIV </asm> C, <asm> RET </asm> THEN / ;

:! < ?COMPILING IF <asm> CPUSH LT </asm> C, <asm> RET </asm> THEN < ;
:! = ?COMPILING IF <asm> CPUSH EQ </asm> C, <asm> RET </asm> THEN = ;
:! > ?COMPILING IF <asm> CPUSH GT </asm> C, <asm> RET </asm> THEN > ;

:! DUP  ?COMPILING IF <asm> CPUSH DUP  </asm> C, <asm> RET </asm> THEN DUP ;
:! SWAP ?COMPILING IF <asm> CPUSH SWAP </asm> C, <asm> RET </asm> THEN SWAP ;
:! DROP ?COMPILING IF <asm> CPUSH DROP </asm> C, <asm> RET </asm> THEN DROP ;
:! ROT  ?COMPILING IF <asm> CPUSH ROT  </asm> C, <asm> RET </asm> THEN ROT ;
:! OVER ?COMPILING IF <asm> CPUSH OVER </asm> C, <asm> RET </asm> THEN OVER ;
:! TUCK ?COMPILING IF <asm> CPUSH TUCK </asm> C, <asm> RET </asm> THEN TUCK ;

:! RESET ?COMPILING IF <asm> CPUSH RESET </asm> C, <asm> RET </asm> THEN RESET ;
:! BYE   ?COMPILING IF <asm> CPUSH BYE   </asm> C, <asm> RET </asm> THEN BYE ;

:! EMIT ?COMPILING IF <asm> CPUSH EMIT </asm> C, <asm> RET </asm> THEN EMIT ;

:! FOPEN ?COMPILING IF <asm> CPUSH FOPEN </asm> C, <asm> RET </asm> THEN FOPEN ;
:! FREAD ?COMPILING IF <asm> CPUSH FREAD </asm> C, <asm> RET </asm> THEN FREAD ;
:! FREADLINE ?COMPILING IF <asm> CPUSH FREADLINE </asm> C, <asm> RET </asm> THEN FREADLINE ;
:! FRWITE ?COMPILING IF <asm> CPUSH FRWITE </asm> C, <asm> RET </asm> THEN FRWITE ;
:! FCLOSE ?COMPILING IF <asm> CPUSH FCLOSE </asm> C, <asm> RET </asm> THEN FCLOSE ;

: 1+ 1 + ;
: 0= 0 = ; : <> = 0= ; : <= > 0= ; : >= < 0= ;
: CRLF 13 EMIT 10 EMIT ;
: BL 32 EMIT ;
: ZTYPE BEGIN DUP C@ DUP IF EMIT 1+ ELSE DROP DROP LEAVE THEN AGAIN ;

: OK BL 79 EMIT 75 EMIT CRLF ;
: HELLO 72 EMIT 73 EMIT ;

: 0SP (STACK) @ SP ! ; 
: PAD LAST 200 - ;
: getInput PAD 128 0 FREADLINE DROP PAD ; \ ( -- addr )

: bye 66 EMIT 89 EMIT 69 EMIT BYE ;

: ?DUP DUP IF DUP THEN ;

: skipWS \ ( addr1 -- addr2 )
	BEGIN
		DUP C@ DUP
		\ DUP EMIT 79 EMIT \ DEBUG
		IF
			\ 80 EMIT \ DEBUG
			32 > 
			\ 81 EMIT \ DEBUG
			IF 
				\ 82 EMIT \ DEBUG
				LEAVE
			ELSE
				\ 83 EMIT \ DEBUG
				1+
			THEN
		ELSE
			\ 84 EMIT DUP ZTYPE CRLF \ DEBUG
			DROP LEAVE
		THEN
	AGAIN
;

: getOneWord \ ( addr1 -- word-addr addr2 )
	DUP >R >R
	BEGIN
		R@ C@ 32 > IF
			R> 1+ >R
		ELSE
			R@ C@ 
			IF
				0 R@ C! R> 1+ >R
			THEN
			R> R> SWAP LEAVE
		THEN
	AGAIN
;

: findInDict \ ( addr -- XT IMM bool )
	0 0 0
;

: isNumber? \ ( addr -- num bool )
	0 0
;

: executeWord  \ ( addr -- )
	70 EMIT DUP ZTYPE 70 EMIT \ debug
	\ TEMP check for "~" (BYE)
	DUP C@ 126 = 
	IF
		DROP bye
	THEN
	
	\ ZTYPE LEAVE DEBUG

	>R R@ findInDict \ ( addr -- XT IMM found )
	IF
		R> DROP
		?COMPILING
		IF
			IF \ Immediate?
				EXECUTE
			ELSE
				<asm> PUSH CALL </asm> C, ,
			THEN
		ELSE
			DROP EXECUTE
		THEN
	ELSE \ word not found
		DROP DROP R> isNumber?
		IF
			?COMPILING
			IF
				DUP 256 <
				IF
					<asm> CPUSH </asm>
				ELSE
					<asm> PUSH </asm>
				THEN
				C, ,
			THEN
		ELSE
			DROP
			44 EMIT \ TODO: error
		THEN
	THEN
;

: executeInput 
	BEGIN 
		65 EMIT >IN @ ZTYPE 65 EMIT CRLF \ debug
		>IN @ skipWS
		\ 66 EMIT CRLF >IN @ ZTYPE CRLF \ debug
		>IN ! >IN @ C@ 
		IF
			\ 67 EMIT >IN @ ZTYPE CRLF \ debug
			>IN @ getOneWord >IN ! executeWord
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

: parseLine getInput 1+ >IN ! executeInput ;

: initSys ;
: resetState 0 STATE ! 10 BASE ! 0SP ;

: mainLoop resetState BEGIN OK parseLine AGAIN ;

: main HELLO initSys mainLoop ;
