\ ------------------------------------------------------------------------------------------
\ This is the source code for the VM's boot loader.
\ This file is compiled by CFComp.exe and an image of the VM's initial state is created.
\ CFComp.exe then disassembles that image, creating a listing file named dis.txt
\ The resulting dis.txt is read by the VM when it boots.
\ ------------------------------------------------------------------------------------------

.ORG 64

: CELL  7  C@ ;
: SP        8 ;
: RSP      12 ;
: (HERE)   16 ;
: (LAST)   20 ;
: STATE    24 ;
: BASE     28 ;
: (STACK)  32 ;
: (RSTACK) 36 ;
: STDIN    40 ;
: INPUT-FP 44 ;
: >IN      48 ;
: isNeg    52 ;

: HERE (HERE) @ ;
: LAST (LAST) @ ;

: CELLS CELL * ; \ ( num1 -- num2 )

: ?COMPILING STATE @ ;
:! [ 0 STATE ! ;
:! ] 1 STATE ! ;

: ,  (HERE) TUCK @ TUCK  ! CELL + SWAP ! ;
: C, (HERE) TUCK @ TUCK C! 1+     SWAP ! ;

:! !  ?COMPILING IF <asm> CPUSH STORE  </asm> C, <asm> RET </asm> THEN ! ;
:! C! ?COMPILING IF <asm> CPUSH CSTORE </asm> C, <asm> RET </asm> THEN C! ;

:! @  ?COMPILING IF <asm> CPUSH FETCH  </asm> C, <asm> RET </asm> THEN @ ;
:! C@ ?COMPILING IF <asm> CPUSH CFETCH </asm> C, <asm> RET </asm> THEN C@ ;

:! + ?COMPILING IF <asm> CPUSH ADD </asm> C, <asm> RET </asm> THEN + ;
:! - ?COMPILING IF <asm> CPUSH SUB </asm> C, <asm> RET </asm> THEN - ;
:! * ?COMPILING IF <asm> CPUSH MUL </asm> C, <asm> RET </asm> THEN * ;
:! / ?COMPILING IF <asm> CPUSH DIV </asm> C, <asm> RET </asm> THEN / ;

:! < ?COMPILING IF <asm> CPUSH LT </asm> C, <asm> RET </asm> THEN < ;
:! = ?COMPILING IF <asm> CPUSH EQ </asm> C, <asm> RET </asm> THEN = ;
:! > ?COMPILING IF <asm> CPUSH GT </asm> C, <asm> RET </asm> THEN > ;

:! DUP  ?COMPILING IF <asm> CPUSH DUP  </asm> C, <asm> RET </asm> THEN DUP ;
:! SWAP ?COMPILING IF <asm> CPUSH SWAP </asm> C, <asm> RET </asm> THEN SWAP ;
:! DROP ?COMPILING IF <asm> CPUSH DROP </asm> C, <asm> RET </asm> THEN DROP ;
:! ROT  ?COMPILING IF <asm> CPUSH ROT  </asm> C, <asm> RET </asm> THEN ROT ;
:! OVER ?COMPILING IF <asm> CPUSH OVER </asm> C, <asm> RET </asm> THEN OVER ;
:! TUCK ?COMPILING IF <asm> CPUSH TUCK </asm> C, <asm> RET </asm> THEN TUCK ;
:! PICK ?COMPILING IF <asm> CPUSH PICK </asm> C, <asm> RET </asm> THEN PICK ;

:! DEPTH ?COMPILING IF <asm> CPUSH DEPTH </asm> C, <asm> RET </asm> THEN DEPTH ;
:! RESET ?COMPILING IF <asm> CPUSH RESET </asm> C, <asm> RET </asm> THEN RESET ;
:! BREAK ?COMPILING IF <asm> CPUSH BREAK </asm> C, <asm> RET </asm> THEN BREAK ;
:! BYE   ?COMPILING IF <asm> CPUSH BYE   </asm> C, <asm> RET </asm> THEN BYE ;

:! EMIT  ?COMPILING IF <asm> CPUSH EMIT  </asm> C, <asm> RET </asm> THEN EMIT ;
:! GETCH ?COMPILING IF <asm> CPUSH GETCH </asm> C, <asm> RET </asm> THEN GETCH ;

:! FOPEN ?COMPILING IF <asm> CPUSH FOPEN </asm> C, <asm> RET </asm> THEN FOPEN ;
:! FREAD ?COMPILING IF <asm> CPUSH FREAD </asm> C, <asm> RET </asm> THEN FREAD ;
:! FREADLINE ?COMPILING IF <asm> CPUSH FREADLINE </asm> C, <asm> RET </asm> THEN FREADLINE ;
:! FRWITE ?COMPILING IF <asm> CPUSH FRWITE </asm> C, <asm> RET </asm> THEN FRWITE ;
:! FCLOSE ?COMPILING IF <asm> CPUSH FCLOSE </asm> C, <asm> RET </asm> THEN FCLOSE ;

:! 1+ ?COMPILING IF <asm> CPUSH ONEPLUS </asm> C, <asm> RET </asm> THEN 1+ ;

: <> = 0 = ; 
: <= > 0 = ; 
: >= < 0 = ;

: CRLF 13 EMIT 10 EMIT ;
: BL 32 EMIT ;
: ZTYPE 
	BEGIN 
		DUP C@ DUP 
		IF EMIT 1+ 
		ELSE DROP DROP LEAVE 
		THEN 
	AGAIN 
;

: TYPE DROP ZTYPE ; ( addr num -- )
: COUNT DUP 1+ SWAP C@ ; \ ( addr1 --  addr2 num )

: PAD LAST 200 - ;
: getInput PAD 128 0 FREADLINE DROP PAD ; \ ( -- addr )

: ?DUP DUP IF DUP THEN ;

: HEX     16 BASE ! ;
: DECIMAL 10 BASE ! ;
: OCTAL    8 BASE ! ;
: BINARY   2 BASE ! ;

\ NB: This algorithm is designed for ZERO delimited strings. But
\ since the counted strings in this implementation are also ZERO 
\ delimited, this algorithm works for them too. For counted strings 
\ with no ZERO delimiter, a different word would need to be written.

: strcmp \ ( addr1 addr2 -- bool )
	BEGIN
		OVER C@
		OVER C@ =
 		IF
			DUP C@ 0 =
			IF DROP DROP 1 LEAVE THEN
			1+ SWAP 1+
		ELSE
			DROP DROP 0 
			LEAVE
		THEN
	AGAIN 
;

: skipWS \ ( addr1 -- addr2 )
	BEGIN
		DUP C@ DUP
		IF
			32 > 
			IF LEAVE ELSE 1+ THEN
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

\ NB: this word assumes that leading WS has already been skipped.
: getOneWord \ ( addr1 -- word-addr addr2 )
	DUP >R >R
	BEGIN
		R@ C@ 32 > IF
			R> 1+ >R
		ELSE
			\ If not at the end of the line, stick a 
			\ ZERO here and go to the next char.
			R@ C@ 
			IF
				0 R@ C! R> 1+ >R
			THEN
			R> R> SWAP LEAVE
		THEN
	AGAIN
;

: findInDict \ ( addr -- XT IMM bool )
	LAST >R
	BEGIN
		R@ DUP
		IF
			2 CELLS 2 + + OVER strcmp
			IF
				DROP R@ CELL + @ R> 2 CELLS + C@ 1
				LEAVE
			THEN
		ELSE
			DROP DROP R> 0 0 LEAVE
		THEN
		R> @ >R
	AGAIN
;

: BETWEEN \ ( num min max -- bool )
	2 PICK 
	< IF DROP DROP 0 LEAVE THEN
	< 0 =
;

: isHEX? BASE @ 16 = ;

: isNumChar? \ ( ch -- val bool )
	DUP 48 57 BETWEEN IF 48 - 1 LEAVE THEN
	isHEX? 
	IF
		DUP 65  70 BETWEEN IF 55 - 1 LEAVE THEN
		DUP 97 102 BETWEEN IF 87 - 1 LEAVE THEN
	THEN
	0
;

: NEGATE 0 SWAP - ; \ ( num1 -- num2 )

: isNumber? \ ( addr -- num bool )
	\ find out if it is negative
	DUP C@ 45 = DUP isNeg C! IF 1+ THEN
	
	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
		DUP 0 = \ end of word?
		IF 
			DROP DROP R> 
			isNeg C@ IF NEGATE THEN
			1 LEAVE
		THEN

		isNumChar? 
		IF
			R> BASE @ * + >R
			1+
		ELSE
			DROP R> 0 LEAVE
		THEN
	AGAIN
;

: /MOD \ ( num1 num2 -- num3 mod )
	OVER OVER / >R R@ * - R> SWAP
;

: (.)  \ ( num -- )
	DUP 0 = 
	IF
		DROP 48 EMIT LEAVE
	THEN
	
	DUP 0 < IF NEGATE 1 ELSE 0 THEN >R

	0 SWAP
	BEGIN
		DUP 0 = 
		IF
			\ TODO spit out the string
			DROP
			R> IF 45 EMIT THEN
			BEGIN ?DUP IF EMIT ELSE LEAVE THEN AGAIN
		ELSE
			BASE @ /MOD 
			48 OVER 9 > IF 7 + THEN
			+ SWAP
		THEN
	AGAIN
;


: . BL (.) ;

: HEX.     BASE @ SWAP HEX     (.) BASE ! ;
: DECIMAL. BASE @ SWAP DECIMAL (.) BASE ! ;
: BINARY.  BASE @ SWAP BINARY  (.) BASE ! ;

: .S 
	DEPTH ?DUP
	IF
		BL 40 EMIT
		1 - >R
		BEGIN 
			R@ PICK . R@ 
			IF
				R> 1 - >R
			ELSE
				R> DROP BL 41 EMIT LEAVE
			THEN
		AGAIN
	ELSE
		BL 40 EMIT 237 EMIT 41 EMIT
	THEN
;

: WORDS \ ( -- )
	LAST
	BEGIN
		DUP @ 0 =
		IF
			DROP CRLF LEAVE
		THEN
		\ DUP 40 EMIT HEX. 41 EMIT BL \ DEBUG
		DUP 2 CELLS 1+ + 
		COUNT TYPE BL
		@
	AGAIN
;

: EXECUTE R> DROP >R ; \ ( addr -- )

: executeWord  \ ( addr -- )
	\ 91 EMIT DUP ZTYPE 93 EMIT \ DEBUG
	>R R@ findInDict \ ( addr -- XT IMM found )
	IF
		R> DROP
		?COMPILING
		IF
			IF \ Immediate?
				EXECUTE
			ELSE
				<asm> PUSH CALL </asm> C, ,
			THEN
		ELSE
			DROP EXECUTE
		THEN
	ELSE \ word not found
		DROP DROP \ discard IMM and XT place holders
		R@ isNumber? \ ( addr -- num bool )
		IF
			?COMPILING
			IF
				DUP 256 <
				IF
					<asm> CPUSH </asm> C, C,
				ELSE
					<asm> PUSH </asm> C, ,
				THEN
			\ ELSE
				\ 65 + EMIT \ DEBUG
			THEN
		ELSE
			DROP
			BL R@ ZTYPE 63 EMIT 63 EMIT RESET \ TODO: error
		THEN
		R> DROP
	THEN
;

: executeInput 
	\ HEX \ DEBUG
	BEGIN 
		\ 65 EMIT >IN @ ZTYPE 65 EMIT CRLF \ DEBUG
		>IN @ skipWS
		\ 66 EMIT CRLF >IN @ ZTYPE CRLF \ DEBUG
		>IN ! >IN @ C@ 
		IF
			\ 67 EMIT >IN @ ZTYPE CRLF \ DEBUG
			>IN @ getOneWord >IN ! executeWord
		ELSE
			LEAVE
		THEN
	AGAIN
;

: resetState 0 STATE ! DECIMAL ;

: OK BL 79 EMIT 75 EMIT .S CRLF ;

: mainLoop resetState BEGIN OK getInput 1+ >IN ! executeInput AGAIN ;

: HELLO >IN @
	IF 
		\ BL 82 EMIT 101 EMIT 115 EMIT 101 EMIT 116 EMIT CRLF 
	ELSE
		72 EMIT 101 EMIT 108 EMIT 108 EMIT 111 EMIT CRLF 
	THEN ;
: main HELLO mainLoop ;
