\ ------------------------------------------------------------------------------------------
\ This is the source code for the VM's boot loader.
\ This file is compiled by CFComp.exe and an image of the VM's initial state is created.
\ CFComp.exe then disassembles that image, creating a listing file named dis.txt
\ The resulting dis.txt is read by the VM when it boots.
\ ------------------------------------------------------------------------------------------

.ORG 64

: SP        8 ;
: RSP      12 ;
: (HERE)   16 ;
: (LAST)   20 ;
: STATE    24 ;
: BASE     28 ;
: (STACK)  32 ;
: (RSTACK) 36 ;
: STDIN    40 ;
: INPUT-FP 44 ;
: >IN      48 ;
: isNeg    52 ;

: HERE (HERE) @ ;
: LAST (LAST) @ ;
: CELL 2 ;

: ?COMPILING STATE @ ;
: [ 0 STATE ! ;
: ] 1 STATE ! ;

: ,  (HERE) TUCK @ TUCK  ! 4 + SWAP ! ;
: C, (HERE) TUCK @ TUCK C! 1+  SWAP ! ;

:! !  ?COMPILING IF <asm> CPUSH STORE  </asm> C, <asm> RET </asm> THEN ! ;
:! C! ?COMPILING IF <asm> CPUSH CSTORE </asm> C, <asm> RET </asm> THEN C! ;

:! @  ?COMPILING IF <asm> CPUSH FETCH  </asm> C, <asm> RET </asm> THEN @ ;
:! C@ ?COMPILING IF <asm> CPUSH CFETCH </asm> C, <asm> RET </asm> THEN C@ ;

:! + ?COMPILING IF <asm> CPUSH ADD </asm> C, <asm> RET </asm> THEN + ;
:! - ?COMPILING IF <asm> CPUSH SUB </asm> C, <asm> RET </asm> THEN - ;
:! * ?COMPILING IF <asm> CPUSH MUL </asm> C, <asm> RET </asm> THEN * ;
:! / ?COMPILING IF <asm> CPUSH DIV </asm> C, <asm> RET </asm> THEN / ;

:! < ?COMPILING IF <asm> CPUSH LT </asm> C, <asm> RET </asm> THEN < ;
:! = ?COMPILING IF <asm> CPUSH EQ </asm> C, <asm> RET </asm> THEN = ;
:! > ?COMPILING IF <asm> CPUSH GT </asm> C, <asm> RET </asm> THEN > ;

:! DUP  ?COMPILING IF <asm> CPUSH DUP  </asm> C, <asm> RET </asm> THEN DUP ;
:! SWAP ?COMPILING IF <asm> CPUSH SWAP </asm> C, <asm> RET </asm> THEN SWAP ;
:! DROP ?COMPILING IF <asm> CPUSH DROP </asm> C, <asm> RET </asm> THEN DROP ;
:! ROT  ?COMPILING IF <asm> CPUSH ROT  </asm> C, <asm> RET </asm> THEN ROT ;
:! OVER ?COMPILING IF <asm> CPUSH OVER </asm> C, <asm> RET </asm> THEN OVER ;
:! TUCK ?COMPILING IF <asm> CPUSH TUCK </asm> C, <asm> RET </asm> THEN TUCK ;

:! RESET ?COMPILING IF <asm> CPUSH RESET </asm> C, <asm> RET </asm> THEN RESET ;
:! BYE   ?COMPILING IF <asm> CPUSH BYE   </asm> C, <asm> RET </asm> THEN BYE ;

:! EMIT ?COMPILING IF <asm> CPUSH EMIT </asm> C, <asm> RET </asm> THEN EMIT ;

:! FOPEN ?COMPILING IF <asm> CPUSH FOPEN </asm> C, <asm> RET </asm> THEN FOPEN ;
:! FREAD ?COMPILING IF <asm> CPUSH FREAD </asm> C, <asm> RET </asm> THEN FREAD ;
:! FREADLINE ?COMPILING IF <asm> CPUSH FREADLINE </asm> C, <asm> RET </asm> THEN FREADLINE ;
:! FRWITE ?COMPILING IF <asm> CPUSH FRWITE </asm> C, <asm> RET </asm> THEN FRWITE ;
:! FCLOSE ?COMPILING IF <asm> CPUSH FCLOSE </asm> C, <asm> RET </asm> THEN FCLOSE ;

:! 1+ ?COMPILING IF <asm> CPUSH ONEPLUS </asm> C, <asm> RET </asm> THEN 1+ ;

: <> = 0 = ; 
: <= > 0 = ; 
: >= < 0 = ;

: CRLF 13 EMIT 10 EMIT ;
: BL 32 EMIT ;
: ZTYPE BEGIN DUP C@ DUP IF EMIT 1+ ELSE DROP DROP LEAVE THEN AGAIN ;

: OK BL 79 EMIT 75 EMIT CRLF ;

: PAD LAST 200 - ;
: getInput PAD 128 0 FREADLINE DROP PAD ; \ ( -- addr )

: bye 66 EMIT 89 EMIT 69 EMIT 46 EMIT BYE ;

: ?DUP DUP IF DUP THEN ;

: HEX 16 BASE ! ;
: DECIMAL 10 BASE ! ;

\ NB: This algorithm is designed for ZERO delimited strings. But
\ since the counted strings in this implementation are also ZERO 
\ delimited, this algorithm works for them too. For counted strings 
\ with no ZERO delimiter, a different word would need to be written.

: strcmp \ ( addr1 addr2 -- bool )
	BEGIN
		OVER C@
		OVER C@ =
 		IF
			DUP C@ 0 =
			IF DROP DROP 1 LEAVE THEN
			1+ SWAP 1+
		ELSE
			DROP DROP 0 
			LEAVE
		THEN
	AGAIN 
;

: skipWS \ ( addr1 -- addr2 )
	BEGIN
		DUP C@ DUP
		IF
			32 > 
			IF LEAVE ELSE 1+ THEN
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

\ NB: this word assumes that leading WS has already been skipped.
: getOneWord \ ( addr1 -- word-addr addr2 )
	DUP >R >R
	BEGIN
		R@ C@ 32 > IF
			R> 1+ >R
		ELSE
			\ If not at the end of the line, stick a 
			\ ZERO here and go to the next char.
			R@ C@ 
			IF
				0 R@ C! R> 1+ >R
			THEN
			R> R> SWAP LEAVE
		THEN
	AGAIN
;

: findInDict \ ( addr -- XT IMM bool )
	LAST @ >R
	BEGIN
		R@ DUP
		IF
			CELL 2 * 2 + + OVER strcmp
			IF
				DROP R@ CELL + @ R> CELL 2 * + C@ 1
				LEAVE
			THEN
		ELSE
			DROP R> 0 0 LEAVE
		THEN
		R> @ >R
	AGAIN
;

: isHexDigit? \ ( ch -- bool )
	BASE @ 16 = 
	IF
			DUP 65 < IF DROP 0 LEAVE THEN
			DUP 70 > IF DROP 0 LEAVE THEN
			DROP 1
	ELSE
		DROP 0
	THEN
;

: isNumChar? \ ( ch -- val bool )
	DUP 48 < IF 0 LEAVE THEN
	DUP 57 > 
	IF 
		DUP isHexDigit?
		IF 
			55
		ELSE 
			DROP 0 LEAVE
		THEN
	ELSE
		48
	THEN
	- 1
;

: isNumber? \ ( addr -- num bool )
	\ find out if it is negative
	DUP C@ 45 = DUP isNeg ! IF 1+ THEN
	
	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
		DUP 0 = \ end of word?
		IF 
			DROP R> 
			isNeg @ IF 0 SWAP - THEN
			1 LEAVE
		THEN

		isNumChar? 
		IF
			R> BASE @ * + >R
			1+
		ELSE
			DROP DROP R> 0 LEAVE
		THEN
	AGAIN
;

: isBYE? \ ( addr -- bool )
	PAD 5 -
	\ (addr) is a string that is not counted.
	96  2 + OVER C! 1+	\ b
	96 25 + OVER C! 1+	\ y
	96  5 + OVER C! 1+	\ e
	 0 SWAP C!
	PAD 5 - strcmp
;

: /MOD \ ( num1 num2 -- num3 mod )
	OVER OVER / >R R@ * - R> SWAP
;

: NEGATE 0 SWAP - ; \ ( num -- -num )

: .  \ ( num -- )
	BL DUP 0 = 
	IF
		48 EMIT LEAVE
	THEN
	
	DUP 0 < IF NEGATE 1 ELSE 0 THEN >R

	0 SWAP
	BEGIN
		DUP 0 = 
		IF
			\ TODO spit out the string
			DROP
			R> IF 45 EMIT THEN
			BEGIN ?DUP IF EMIT ELSE LEAVE THEN AGAIN
		ELSE
			BASE @ /MOD 48 + SWAP
		THEN
	AGAIN
;

: EXECUTE R> DROP >R ; \ ( addr -- )

: executeWord  \ ( addr -- )
	\ 91 EMIT DUP ZTYPE 93 EMIT \ DEBUG
	DUP isBYE? IF DROP bye THEN

	>R R@ findInDict \ ( addr -- XT IMM found )
	IF
		R> DROP
		?COMPILING
		IF
			IF \ Immediate?
				EXECUTE
			ELSE
				<asm> PUSH CALL </asm> C, ,
			THEN
		ELSE
			DROP EXECUTE
		THEN
	ELSE \ word not found
		DROP DROP \ discard IMM and XT place holders
		R@ isNumber? \ ( addr -- num bool )
		IF
			?COMPILING
			IF
				DUP 256 <
				IF
					<asm> CPUSH </asm>
				ELSE
					<asm> PUSH </asm>
				THEN
				C, ,
			\ ELSE
				\ 65 + EMIT \ DEBUG
			THEN
		ELSE
			DROP
			BL R@ ZTYPE 63 EMIT 63 EMIT RESET \ TODO: error
		THEN
		R> DROP
	THEN
;

: executeInput 
	\ HEX \ DEBUG
	BEGIN 
		\ 65 EMIT >IN @ ZTYPE 65 EMIT CRLF \ DEBUG
		>IN @ skipWS
		\ 66 EMIT CRLF >IN @ ZTYPE CRLF \ DEBUG
		>IN ! >IN @ C@ 
		IF
			\ 67 EMIT >IN @ ZTYPE CRLF \ DEBUG
			>IN @ getOneWord >IN ! executeWord
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

: resetState 0 STATE ! DECIMAL ;

: mainLoop resetState BEGIN OK getInput 1+ >IN ! executeInput AGAIN ;

: HELLO >IN @ 0 = IF 72 EMIT 73 EMIT THEN ;
: test 17 NEGATE . 12345 . ;
: main HELLO test mainLoop ;
