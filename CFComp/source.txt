.ORG 64

: SP        8 ;
: RSP      12 ;
: (HERE)   16 ;
: (LAST)   20 ;
: STATE    24 ;
: BASE     28 ;
: (STACK)  32 ;
: (RSTACK) 36 ;
: STDIN    40 ;
: INPUT-FP 44 ;
: >IN      48 ;
: isNeg    52 ;

: HERE (HERE) @ ;
: LAST (LAST) @ ;

: ?COMPILING STATE @ ;
: [ 0 STATE ! ;
: ] 1 STATE ! ;

: ,  HERE TUCK  ! 4 + (HERE) ! ;
: C, HERE TUCK C! 1+ (HERE) ! ;

:! !  ?COMPILING IF <asm> CPUSH STORE  </asm> C, <asm> RET </asm> THEN ! ;
:! C! ?COMPILING IF <asm> CPUSH CSTORE </asm> C, <asm> RET </asm> THEN C! ;

:! @  ?COMPILING IF <asm> CPUSH FETCH  </asm> C, <asm> RET </asm> THEN @ ;
:! C@ ?COMPILING IF <asm> CPUSH CFETCH </asm> C, <asm> RET </asm> THEN C@ ;

:! + ?COMPILING IF <asm> CPUSH ADD </asm> C, <asm> RET </asm> THEN + ;
:! - ?COMPILING IF <asm> CPUSH SUB </asm> C, <asm> RET </asm> THEN - ;
:! * ?COMPILING IF <asm> CPUSH MUL </asm> C, <asm> RET </asm> THEN * ;
:! / ?COMPILING IF <asm> CPUSH DIV </asm> C, <asm> RET </asm> THEN / ;

:! < ?COMPILING IF <asm> CPUSH LT </asm> C, <asm> RET </asm> THEN < ;
:! = ?COMPILING IF <asm> CPUSH EQ </asm> C, <asm> RET </asm> THEN = ;
:! > ?COMPILING IF <asm> CPUSH GT </asm> C, <asm> RET </asm> THEN > ;

:! DUP  ?COMPILING IF <asm> CPUSH DUP  </asm> C, <asm> RET </asm> THEN DUP ;
:! SWAP ?COMPILING IF <asm> CPUSH SWAP </asm> C, <asm> RET </asm> THEN SWAP ;
:! DROP ?COMPILING IF <asm> CPUSH DROP </asm> C, <asm> RET </asm> THEN DROP ;
:! ROT  ?COMPILING IF <asm> CPUSH ROT  </asm> C, <asm> RET </asm> THEN ROT ;
:! OVER ?COMPILING IF <asm> CPUSH OVER </asm> C, <asm> RET </asm> THEN OVER ;
:! TUCK ?COMPILING IF <asm> CPUSH TUCK </asm> C, <asm> RET </asm> THEN TUCK ;

:! RESET ?COMPILING IF <asm> CPUSH RESET </asm> C, <asm> RET </asm> THEN RESET ;
:! BYE   ?COMPILING IF <asm> CPUSH BYE   </asm> C, <asm> RET </asm> THEN BYE ;

:! EMIT ?COMPILING IF <asm> CPUSH EMIT </asm> C, <asm> RET </asm> THEN EMIT ;

:! FOPEN ?COMPILING IF <asm> CPUSH FOPEN </asm> C, <asm> RET </asm> THEN FOPEN ;
:! FREAD ?COMPILING IF <asm> CPUSH FREAD </asm> C, <asm> RET </asm> THEN FREAD ;
:! FREADLINE ?COMPILING IF <asm> CPUSH FREADLINE </asm> C, <asm> RET </asm> THEN FREADLINE ;
:! FRWITE ?COMPILING IF <asm> CPUSH FRWITE </asm> C, <asm> RET </asm> THEN FRWITE ;
:! FCLOSE ?COMPILING IF <asm> CPUSH FCLOSE </asm> C, <asm> RET </asm> THEN FCLOSE ;

:! 1+ ?COMPILING IF <asm> CPUSH ONEPLUS </asm> C, <asm> RET </asm> THEN 1+ ;

: 0= 0 = ; : <> = 0= ; : <= > 0= ; : >= < 0= ;
: CRLF 13 EMIT 10 EMIT ;
: BL 32 EMIT ;
: ZTYPE BEGIN DUP C@ DUP IF EMIT 1+ ELSE DROP DROP LEAVE THEN AGAIN ;

: OK BL 79 EMIT 75 EMIT CRLF ;
: HELLO >IN @ 0= IF 72 EMIT 73 EMIT THEN ;

: PAD LAST 200 - ;
: getInput PAD 128 0 FREADLINE DROP PAD ; \ ( -- addr )

: bye 66 EMIT 89 EMIT 69 EMIT BYE ;

: ?DUP DUP IF DUP THEN ;

: HEX 16 BASE ! ;
: DECIMAL 10 BASE ! ;

: skipWS \ ( addr1 -- addr2 )
	BEGIN
		DUP C@ DUP
		\ DUP EMIT 79 EMIT \ DEBUG
		IF
			\ 80 EMIT \ DEBUG
			32 > 
			\ 81 EMIT \ DEBUG
			IF 
				\ 82 EMIT \ DEBUG
				LEAVE
			ELSE
				\ 83 EMIT \ DEBUG
				1+
			THEN
		ELSE
			\ 84 EMIT DUP ZTYPE CRLF \ DEBUG
			DROP LEAVE
		THEN
	AGAIN
;

: getOneWord \ ( addr1 -- word-addr addr2 )
	DUP >R >R
	BEGIN
		R@ C@ 32 > IF
			R> 1+ >R
		ELSE
			R@ C@ 
			IF
				0 R@ C! R> 1+ >R
			THEN
			R> R> SWAP LEAVE
		THEN
	AGAIN
;

: findInDict \ ( addr -- XT IMM bool )
	\ TODO
	0 0 0 \ DEBUG
;

: isHexDigit? \ ch -- bool
	BASE @ 16 = 
	IF
			DUP 65 < IF DROP 0 LEAVE THEN
			DUP 70 > IF DROP 0 LEAVE THEN
			DROP 1
	ELSE
		DROP 0
	THEN
;

: isNumChar? \ ch -- val bool
	DUP 48 < IF 0 LEAVE THEN
	DUP 57 > 
	IF 
		DUP isHexDigit?
		IF 
			55
		ELSE 
			DROP 0 LEAVE
		THEN
	ELSE
		48
	THEN
	- 1
;

: isNumber? \ ( addr -- num bool )
	\ find out if it is negative
	DUP C@ 45 = DUP isNeg ! IF 1+ THEN
	
	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
		DUP 0= \ end of word?
		IF 
			DROP R> 
			isNeg @ IF 0 SWAP - THEN
			1 LEAVE
		THEN

		isNumChar? 
		IF
			R> BASE @ * + >R
			1+
		ELSE
			DROP DROP R> 0 LEAVE
		THEN
	AGAIN
;

: executeWord  \ ( addr -- )
	\ 91 EMIT DUP ZTYPE 93 EMIT \ DEBUG
	\ TEMP check for "~" (BYE)
	DUP C@ 126 = 
	IF
		DROP bye
	THEN
	
	>R R@ findInDict \ ( addr -- XT IMM found )
	IF
		R> DROP
		?COMPILING
		IF
			IF \ Immediate?
				EXECUTE
			ELSE
				<asm> PUSH CALL </asm> C, ,
			THEN
		ELSE
			DROP EXECUTE
		THEN
	ELSE \ word not found
		DROP DROP \ discard IMM and XT placeholders
		R@ isNumber? \ ( addr -- num bool )
		IF
			?COMPILING
			IF
				DUP 256 <
				IF
					<asm> CPUSH </asm>
				ELSE
					<asm> PUSH </asm>
				THEN
				C, ,
			\ ELSE
				\ 65 + EMIT \ DEBUG
			THEN
		ELSE
			DROP
			32 EMIT R@ ZTYPE 63 EMIT 63 EMIT RESET \ TODO: error
		THEN
		R> DROP
	THEN
;

: executeInput 
	\ HEX \ DEBUG
	BEGIN 
		\ 65 EMIT >IN @ ZTYPE 65 EMIT CRLF \ DEBUG
		>IN @ skipWS
		\ 66 EMIT CRLF >IN @ ZTYPE CRLF \ DEBUG
		>IN ! >IN @ C@ 
		IF
			\ 67 EMIT >IN @ ZTYPE CRLF \ DEBUG
			>IN @ getOneWord >IN ! executeWord
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

: parseLine getInput 1+ >IN ! executeInput ;

: initSys ;
: resetState 0 STATE ! DECIMAL ;

: mainLoop resetState BEGIN OK parseLine AGAIN ;

: main HELLO initSys mainLoop ;
